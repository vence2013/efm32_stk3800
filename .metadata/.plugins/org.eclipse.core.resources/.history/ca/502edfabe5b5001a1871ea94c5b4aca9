#include "em_chip.h"
#include "bsp_trace.h"
#include "em_rmu.h"
#include "em_emu.h"
#include "em_cmu.h"
#include "em_burtc.h"
#include "hal.h"
#include "utils.h"

static uint32_t resetcause = 0;
static uint32_t burtcCountAtWakeup = 0;

/***************************************************************************//**
 * @brief Set up backup domain.
 ******************************************************************************/
void budSetup(void)
{
	/* Assign default TypeDefs */
	EMU_EM4Init_TypeDef em4Init = EMU_EM4INIT_DEFAULT;
	EMU_BUPDInit_TypeDef bupdInit = EMU_BUPDINIT_DEFAULT;

	/*Setup EM4 configuration structure */
	em4Init.lockConfig = true;
	em4Init.osc = emuEM4Osc_LFXO;
	em4Init.buRtcWakeup = true;
	em4Init.vreg = true;

	/* Setup Backup Power Domain configuration structure */
	bupdInit.probe = emuProbe_Disable;
	bupdInit.bodCal = false;
	bupdInit.statusPinEnable = false;
	bupdInit.resistor = emuRes_Res0;
	bupdInit.voutStrong = false;
	bupdInit.voutMed = false;
	bupdInit.voutWeak = false;
	bupdInit.inactivePower = emuPower_MainBU;
	bupdInit.activePower = emuPower_None;
	bupdInit.enable = true;

	/* Unlock configuration */
	EMU_EM4Lock( false );

	/* Initialize EM4 and Backup Power Domain with init structs */
	EMU_BUPDInit( &bupdInit );
	EMU_EM4Init( &em4Init );

	/* Release reset for backup domain */
	RMU_ResetControl( rmuResetBU, false );

	/* Lock configuration */
	EMU_EM4Lock( true );
}

/******************************************************************************
 * @brief   Configure backup RTC
 *****************************************************************************/
void burtcSetup(void)
{
	/* Create burtcInit struct and fill with default values */
	BURTC_Init_TypeDef burtcInit = BURTC_INIT_DEFAULT;

	/* Set burtcInit to proper values for this application */
	/* To make this example easier to read, all fields are listed,
	even those which are equal to their default value */
	burtcInit.enable = true;
	burtcInit.mode = burtcModeEM4;
	burtcInit.debugRun = false;
	burtcInit.clkSel = burtcClkSelLFXO;
	burtcInit.clkDiv = burtcClkDiv_128;
	burtcInit.timeStamp = true;
	burtcInit.compare0Top = false;
	burtcInit.lowPowerMode = burtcLPDisable;

	/* Initialize BURTC with burtcInit struct */
	BURTC_Init( &burtcInit );

	BURTC_CompareSet( 0, COUNTS_BETWEEN_UPDATE );

	/* Enable BURTC interrupt on compare match and counter overflow */
	BURTC_IntEnable( BURTC_IF_COMP0 | BURTC_IF_OF );
}

int main(void)
{
	/* Chip errata */
	CHIP_Init();
	/* If first word of user data page is non-zero, enable Energy Profiler trace */
	BSP_TraceProfilerSetup();

	/* Read and clear RMU->RSTCAUSE as early as possible */
	resetcause = RMU_ResetCauseGet();
	RMU_ResetCauseClear();
	/* Enable clock to low energy modules */
	CMU_ClockEnable(cmuClock_CORELE, true);
	/* Read Backup Real Time Counter value */
	burtcCountAtWakeup = BURTC_CounterGet();

	budSetup();

	/* Infinite loop */
	while (1) {
		Drv_led_toggle( LED0 );

		delay_ms( 1000 );
	}
}
